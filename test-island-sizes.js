// Test script to analyze island sizes generated by the map system
const ROT = require('rot-js');

// Seeded random class
class SeededRandom {
    constructor(seed) {
        this.seed = seed;
    }

    setSeed(seed) {
        this.seed = seed;
    }

    random() {
        const x = Math.sin(this.seed++) * 10000;
        return x - Math.floor(x);
    }

    nextInt(min, max) {
        return Math.floor(this.random() * (max - min + 1)) + min;
    }
}

// Simple MapGenerator for testing
class TestMapGenerator {
    constructor(seed = 12345) {
        this.map = new Map();
        this.seed = seed;
        this.seededRandom = new SeededRandom(this.seed);

        // Initialize noise generators
        this.elevationNoise = new ROT.Noise.Simplex();
        this.moistureNoise = new ROT.Noise.Simplex();
        this.temperatureNoise = new ROT.Noise.Simplex();
    }

    generateChunkAt(x, y) {
        const key = `${x},${y}`;
        if (this.map.has(key)) {
            return this.map.get(key);
        }

        // Same generation logic as map.js
        const baseScale = 0.025;
        const islandScale = 0.12;
        const atollScale = 0.2;

        let elevation = 0.2;

        const continentNoise = (this.elevationNoise.get(x * baseScale, y * baseScale) + 1) / 2;
        if (continentNoise > 0.75) {
            elevation += (continentNoise - 0.75) * 1.8;
        }

        const islandNoise = (this.elevationNoise.get(x * islandScale + 500, y * islandScale + 500) + 1) / 2;
        if (islandNoise > 0.7) {
            elevation += (islandNoise - 0.7) * 1.3;
        }

        const atollNoise = (this.elevationNoise.get(x * atollScale + 1000, y * atollScale + 1000) + 1) / 2;
        if (atollNoise > 0.75) {
            elevation += (atollNoise - 0.75) * 1.0;
        }

        const chainScale = 0.06;
        const chain1 = (this.elevationNoise.get(x * chainScale + 1500, y * chainScale + 1500) + 1) / 2;
        const chain2 = (this.elevationNoise.get(x * chainScale + 2500, y * chainScale + 2500) + 1) / 2;
        const chain3 = (this.elevationNoise.get(x * chainScale + 3500, y * chainScale + 3500) + 1) / 2;

        if (chain1 > 0.8) elevation += (chain1 - 0.8) * 1.5;
        if (chain2 > 0.85) elevation += (chain2 - 0.85) * 1.2;
        if (chain3 > 0.82) elevation += (chain3 - 0.82) * 1.0;

        const moisture = (this.moistureNoise.get(x * 0.09 + 100, y * 0.09 + 100) + 1) / 2;
        const temperature = (this.temperatureNoise.get(x * 0.07 + 200, y * 0.07 + 200) + 1) / 2;

        elevation = Math.max(0, Math.min(1, elevation));

        const biome = this.determineBiome(elevation, moisture, temperature);

        const tile = {
            x: x,
            y: y,
            biome: biome,
            elevation: elevation
        };

        this.map.set(key, tile);
        return tile;
    }

    determineBiome(elevation, moisture, temperature) {
        if (elevation < 0.3) return 'ocean';
        else if (elevation < 0.4) return 'ocean';
        else if (elevation < 0.45) return 'beach';
        else if (elevation > 0.9) {
            if (temperature < 0.4) return 'snow';
            else return 'mountain';
        } else if (moisture < 0.15) {
            if (temperature > 0.75) return 'desert';
            else return 'savanna';
        } else if (moisture > 0.85) {
            if (temperature > 0.75) return 'jungle';
            else return 'swamp';
        } else if (temperature < 0.2) return 'taiga';
        else if (temperature > 0.8) return 'tropical';
        else return 'forest';
    }

    // Flood fill to measure actual island size
    measureIsland(startX, startY, visited = new Set()) {
        const tile = this.generateChunkAt(startX, startY);
        if (!tile || tile.biome === 'ocean') return 0;

        const key = `${startX},${startY}`;
        if (visited.has(key)) return 0;

        visited.add(key);
        let size = 1;

        // Check all 4 directions
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dx, dy] of directions) {
            size += this.measureIsland(startX + dx, startY + dy, visited);
        }

        return size;
    }
}

// Analyze island distribution
function analyzeIslandDistribution(size = 300, seed = 12345) {
    console.log(`\nAnalyzing island sizes in ${size}x${size} area...`);
    console.log(`Using seed: ${seed}`);

    const mapGen = new TestMapGenerator(seed);
    const processedIslands = new Set();
    const islandSizes = [];

    let totalLandTiles = 0;
    let totalTiles = size * size;

    // Scan the entire area
    for (let y = -size/2; y < size/2; y++) {
        for (let x = -size/2; x < size/2; x++) {
            const tile = mapGen.generateChunkAt(x, y);

            if (tile.biome !== 'ocean') {
                totalLandTiles++;

                const key = `${x},${y}`;
                if (!processedIslands.has(key)) {
                    // Found a new island - measure it
                    const islandVisited = new Set();
                    const islandSize = mapGen.measureIsland(x, y, islandVisited);

                    // Mark all tiles of this island as processed
                    for (const visitedKey of islandVisited) {
                        processedIslands.add(visitedKey);
                    }

                    islandSizes.push(islandSize);
                }
            }
        }
    }

    // Sort island sizes
    islandSizes.sort((a, b) => b - a);

    // Calculate statistics
    const waterPercentage = ((totalTiles - totalLandTiles) / totalTiles * 100).toFixed(1);
    const landPercentage = (totalLandTiles / totalTiles * 100).toFixed(1);

    console.log(`\n=== OVERALL STATISTICS ===`);
    console.log(`Total tiles: ${totalTiles}`);
    console.log(`Land tiles: ${totalLandTiles} (${landPercentage}%)`);
    console.log(`Water tiles: ${totalTiles - totalLandTiles} (${waterPercentage}%)`);
    console.log(`Total islands found: ${islandSizes.length}`);

    // Size distribution
    const sizeCategories = {
        'Tiny (<10)': 0,
        'Small (10-30)': 0,
        'Medium (30-80)': 0,
        'Large (80-150)': 0,
        'Huge (150-300)': 0,
        'Massive (>300)': 0
    };

    for (const size of islandSizes) {
        if (size < 10) sizeCategories['Tiny (<10)']++;
        else if (size < 30) sizeCategories['Small (10-30)']++;
        else if (size < 80) sizeCategories['Medium (30-80)']++;
        else if (size < 150) sizeCategories['Large (80-150)']++;
        else if (size < 300) sizeCategories['Huge (150-300)']++;
        else sizeCategories['Massive (>300)']++;
    }

    console.log(`\n=== ISLAND SIZE DISTRIBUTION ===`);
    for (const [category, count] of Object.entries(sizeCategories)) {
        console.log(`${category.padEnd(25)} ${count} islands`);
    }

    // Top 20 largest islands
    console.log(`\n=== TOP 20 LARGEST ISLANDS ===`);
    const top20 = islandSizes.slice(0, 20);
    top20.forEach((size, index) => {
        const category =
            size < 10 ? 'Tiny' :
            size < 30 ? 'Small' :
            size < 80 ? 'Medium' :
            size < 150 ? 'Large' :
            size < 300 ? 'Huge' : 'Massive';
        console.log(`${(index + 1).toString().padStart(2)}. ${size.toString().padStart(5)} tiles (${category})`);
    });

    // Average island size
    const avgSize = (islandSizes.reduce((a, b) => a + b, 0) / islandSizes.length).toFixed(1);
    console.log(`\n=== ISLAND SIZE STATISTICS ===`);
    console.log(`Average island size: ${avgSize} tiles`);
    console.log(`Median island size: ${islandSizes[Math.floor(islandSizes.length / 2)]} tiles`);
    console.log(`Largest island: ${islandSizes[0]} tiles`);
    console.log(`Smallest island: ${islandSizes[islandSizes.length - 1]} tiles`);

    return {
        islandSizes,
        sizeCategories,
        waterPercentage,
        landPercentage,
        avgSize
    };
}

// Run the analysis
console.log('='.repeat(60));
console.log('PIRATE SEA - ISLAND SIZE ANALYSIS');
console.log('='.repeat(60));

analyzeIslandDistribution(300, 12345);

console.log('\n' + '='.repeat(60));
console.log('Analysis complete!');
console.log('='.repeat(60));
